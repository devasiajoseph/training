#+STYLE: <link rel="stylesheet" type="text/css" href="css/bootstrap/css/bootstrap.min.css" />
#+STYLE: <link rel="stylesheet" type="text/css" href="css/custom.css" />
#+TITLE: Clojure Training

* Intro to Functional Programming with Clojure

** What is functional programming
   Functions are first class objects
    - It can be created on demand.
    - It can be stored in a data structure.
    - It can be passed as an argument to a function.
    - It can be returned as the value of a function.

*** Why do we need functional programming?

    
    In computer science, functional programming is a programming paradigm style of building the structure and elements of computer programs that treats computation as the evaluation of
    mathematical functions and avoids changing-state and mutable data.

    Functional programming makes it easy to implement distributed/parallel computing.
    
    Moore's law for computing hardware is fluctuating. Processors are not getting faster anymore.
    More efficient computing is achieved by adding more cores.


** Higher order functions
   Functions that can take functions or values as an input and return a new function or functions as output.
   
** Anonymous Functions
   Anonymous functtions are functions without an identity or a name.
   These type of functions are commonly used as callbacks for an event where no other reference is needed.
   Another use case for anonymous functions is using it as a filter for a data set or applying a functional transformation for a set of data
   
** Functional composition
   "Function Composition" is applying one function to the results of another.
   You can have a pipe line of functions through which data is passed through. And this pipe line can be termed as a new function.
   You can create a new function from a set of functions.

** Pure functions and immutablilty

   Pure function is a function which has no side effects. It does not depend on any external entities.
   For every input, there is only one out put
   Example: Area of a circle = pi*r*r
   
   Examples of impure functions: current time, or time related functions. Database operations. File operations or reading data from an external API
   
   
** Map Reduce Filter

   Map reduce is a programming model. A map reduce approach helps in distributed computing.

*** Map
    Common syntax:
    
    map->function->data set

    Outputs a set of data
    
    Function in a map accepts a value or another function.

    Example case: Increment every value in an array by one

    syntax: map increment-function array
   
*** Reduce
    Common syntax:

    reduce->function <optional initial value> -> data set
    
    Reduce function accepts two values, previous value and next value
    Returns a single output entity which is a reduced form of dataset
    
    

* Intoduction to Clojure

** What is Clojure
   Clojure is a general purpose, compiled, dynamic, functional programming language.
   Clojure is a member of the Lisp family of languages.
   Lisp was a revolutionary programming language which first appeared in 1958 and was too advanced at that time.
   Lisp was originally created as a practical mathematical notation for computer programs, influenced by lambda calculus
   
** Advantages of Clojure
   - Clojure is simple. *Simple is elegant, simple is beautiful.*
   - Clojure uses lesser lines of code. Anywhere between 10-20x lesser lines of code than Java.
   - Clojure is a Lisp. *Code is Data*
   - Clojure is functional *Functional programming will be a necessary programming model in the near future*
   - Clojure supports true concurrent models
   - Clojure REPL helps in interactive development
   - Clojure runs on JVM
     It can take advantage of highly optimized JVM and its garbage collector. It can utilize Java libraries
   - Clojure can be used as a replacement for javascript in the front end
   
   
   
** Disadvantages of Clojure
   - Major shift in programming model.
   - Lisp syntax is different and some people never gets it.
   - Relatively new technology. Released in 2007 and fewer libraries and developers
   
** Installing Clojure
   Using Leiningen http://leiningen.org/
   
   1. Download the lein script (or on Windows lein.bat)
   2. Place it on your $PATH where your shell can find it (eg. ~/bin)
   3. Set it to be executable (chmod a+x ~/bin/lein)
   4. Run it (lein) and it will download the self-install package
   
     #+BEGIN_SRC bash
     lein new <project-name>
     #+END_SRC
   This command will start a new project

** Tooling

*** IDE
    Clojure syntax is very simple that you don't actually need an IDE. You can do Clojure development in a simple text editor.
    
    Recommended editors/IDE:
    
    1. Emacs: *Unlimited awesomeness* https://www.gnu.org/software/emacs/
       Emacs is built with a Lisp. Highly customizable. Steeper learning curve.
    2. Cursive: *For the software engineer* https://cursive-ide.com/
    3. Eclipse + Counterclockwise *For the enterprise developer who is already working on Java* http://doc.ccw-ide.org/documentation.html
       
    
* Basic Clojure Syntax and REPL

** Lisp syntax
   Clojure is a homoiconic language, which means Clojure code itself is a data (list). Clojure code is executed by evaluating a data structure. Clojure code can modify, transform and create other Clojure programs.
   *Programs creating programs.*
   Recommended Reading for more enlightenment: http://clojure.org/reference/reader
   
** The REPL
   *The Read Eval Print Loop* 
   Clojure REPL is an interactive shell which can be connected to a running program and modifications can be made and tested on a live program.
   
   Staring a REPL
   
   cd into your project folder
    #+BEGIN_SRC bash
     lein repl
    #+END_SRC
   
   
** Code execution and Project Structure

    Creating a project:
    
     #+BEGIN_SRC bash
      lein new <project-name>
      #+END_SRC
    
    Running a project 

     #+BEGIN_SRC bash
      lein run
     #+END_SRC

    The "main" entry point will be executed.

    The main entry point is defined in the project.clj file in the project folder {:main tutorial.core}
    
    Clojure code is organized similar to JAVA projects
    

*** Source code
    Source code path is defined in project as {:source-paths ["src/clj"]}
    It is a common practice to put all the clojure source code inside "src/clj". 
    
    Clojure project may contain java source code or clojurescript source code. They will be put inside "src/java" or "src/cljs" directories.

    Java source code path must be defined using the key :java-source-paths
    Java source code path example :java-source-paths ["src/java"]
     
* Clojure Namespaces
  
  
** What is a namespace?
   
   Namespace is a structural identity of a source code file.
   
   - What def does
   - What namespaces are and how to use them
   - The relationship between namespaces and the filesystem
   - How to use refer, alias, require, use, and ns
   - How to organize Clojure projects using the filesystem

   
** The 'user' namespace
   When you start the REPL, for example, you are in the user namespace
   
** Using code in other namespaces
   - require (strict)
   - use (import everything into this namespace)
   - refer (refer particular functions only)
   
** require, use, and import

   #+BEGIN_SRC clojure
   (ns myproject.core
    (:use [clojure.core] :reload)
    (:require [clojure.string :as str :refer [replace]] :reload-all))

    (str/replace "foo" #"o" "e")
   "fee"
   #+END_SRC
   
** Reloading namespaces
   
   
** The namespace declaration
   (ns directory-path.filename)
   
* TODO Working with Java Code & Clojure

** Importing Java packages
** Using static class members
** Creating objects
** Calling instance methods
   
* More Clojure Syntax

** Execution (do, doseq, dotimes)
    #+BEGIN_SRC clojure
       (do  something)
    #+END_SRC
   
   #+BEGIN_SRC clojure
   (doseq [each all]
     (do-something each))
   #+END_SRC
     
** Conditionals (if, cond, condp, case)
   #+BEGIN_SRC clojure
   (if test then else?) 
   #+END_SRC
   
   OR
   
   #+BEGIN_SRC clojure
   (if test then)
   #+END_SRC

** Iteration (while, for, loop)
   #+BEGIN_SRC clojure
(while condition
(do-somthing))
   #+END_SRC
   
** Recursion
   Factorial Example:
   
   #+BEGIN_SRC clojure
   (defn fact[x]
  (if (<= x 1) 1 (* x  (fact (- x 1))  )))
   #+END_SRC

   Use recursion only when no other way is possible. Most of the time you can use *reduce* operation to attain the same result

   Alternate way of implementing factorial without recursion:

   #+BEGIN_SRC clojure
(defn fact[n]
(if (= 0 n) 1 (reduce * (range 1 (inc n)))))
   #+END_SRC
   
** Tail recursion
   Factorial example:

   #+BEGIN_SRC clojure
   (defn fact [x]
    (loop [n x f 1]
        (if (= n 1)
            f
            (recur (dec n) (* f n)))))
   #+END_SRC
   
   Clojure will do tail-call optimization for this; that ensures that you will never run into StackOverflowErrors.
   
** Exception handling
   
   The exprs are evaluated and, if no exceptions occur, the value of the last
   is returned. If an exception occurs and catch clauses are provided, each is
   examined in turn and the first for which the thrown exception is an instance
   of the named class is considered a matching catch clause
   
   #+BEGIN_SRC clojure
   (try
     (/ 1 0)
     (catch Exception e (str "caught exception: " (.getMessage e))))
   #+END_SRC
   
** Destructuring
   
   
** Using :keys and :or Named arguments
   
   
* Macros

** Exploring Macros
   The number one rule of Macros: *Don't use macros*

   Most of the problems can be solved using functional programming. Use macros only if you need to create a DSL
   like a query language for a particular Database or a very specific functionality set that is repeated very often.

   99% of the time you don't need macros
 
** Creating our Own Macros
   
** Using Templating to Create Macros
   
   
* Data Structures
** The four basic structures:
** lists
   Everything is a list. Even clojure source code is a list
   
   
** vectors
   Similar to arrays.
   
   Example:
   
   
** maps
   {:key value}
** sets
   Sets

Sets are collections of unique values.

There is literal support for hash-sets:

#{:a :b :c :d}
-> #{:d :a :b :c}
You can create sets with the hash-set and sorted-set functions:

(hash-set :a :b :c :d)
-> #{:d :a :b :c}

(sorted-set :a :b :c :d)
-> #{:a :b :c :d}
You can also get a set of the values in a collection using the set function:


** Sequences
   
   A logical list
** Lazy Sequences
** Operations on sequences (eg map, reduce, filter)
   
** Design Considerations for Clojure programming
   
* Polymorphism
** Protocols
** Defining and using Types
** Defining and using Records
** Handling Java with interop

* Intro to Concurency


* Intro to Web Programming with Clojure
** Ring
** Compojure
** Other foundational libraries


** Web Programming with Clojure (contd)
** Restful Services with Clojure
** HTML Templating library
** REST API library
** State Management in projects
** Clojurescript introduction (optional)
** Deployment


